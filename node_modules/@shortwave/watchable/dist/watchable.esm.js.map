{"version":3,"file":"watchable.esm.js","sources":["../src/utils.ts","../src/watchable.ts","../src/hooks.ts"],"sourcesContent":["export interface Box<T> {\n  current: T;\n}\n\nexport type Unsubscribe = () => void;\n\nexport class Subscriptions<CallbackType> {\n  private callbacks = new Set<CallbackType>();\n\n  add(fn: CallbackType): Unsubscribe {\n    if (this.callbacks.has(fn)) {\n      throw new Error(\"Can't add subscription twice!\");\n    }\n    this.callbacks.add(fn);\n    return () => {\n      const hadValue = this.callbacks.delete(fn);\n      if (!hadValue) {\n        throw new Error('Did not find callback function for unsubscribe');\n      }\n    };\n  }\n\n  isEmpty(): boolean {\n    return this.callbacks.size === 0;\n  }\n\n  forEach(callback: (cb: CallbackType) => void): void {\n    // Make a copy to support sync removal.\n    return Array.from(this.callbacks).forEach(callback);\n  }\n}\n\nexport function memoizeLatest<Input, Output>(\n  fn: (i: Input) => Output\n): (i: Input) => Output {\n  let latest: { input: Input; output: Output } | null = null;\n  return (input) => {\n    if (!latest) {\n      latest = { input, output: fn(input) };\n    } else if (latest.input !== input) {\n      latest.input = input;\n      latest.output = fn(input);\n    }\n    return latest.output;\n  };\n}\n\nexport interface MapLike<K, V> {\n  get(key: K): V | undefined;\n  set(key: K, value: V): void;\n  has(k: K): boolean;\n  readonly size: number;\n  [Symbol.iterator](): IterableIterator<[K, V]>;\n  keys(): IterableIterator<K>;\n  values(): IterableIterator<V>;\n}\n\nexport type MapFactory<K, V> = () => Map<K, V>;\n\nexport function defaultMapFactory<K, V>(): Map<K, V> {\n  return new Map();\n}\n","import { Subscriptions, Unsubscribe, Box, memoizeLatest } from './utils';\n\nexport type WatcherFn<T> = (value: T) => void;\n\ninterface WatchableLike<T> {\n  /** If this watchable has a current value. */\n  hasValue(): boolean;\n  /** Get the current value for this watchable, requires `hasValue` returns true. */\n  getValue(): T;\n\n  /** Watch this for updates. The current value will be replayed here. */\n  watch(watch: WatcherFn<T>): Unsubscribe;\n}\n\nexport abstract class Watchable<T> implements WatchableLike<T> {\n  abstract hasValue(): boolean;\n  abstract getValue(): T;\n  getOrDefault<V>(defaultValue: V): T | V {\n    return this.hasValue() ? this.getValue() : defaultValue;\n  }\n\n  abstract watch(watcher: WatcherFn<T>): Unsubscribe;\n\n  /* Transform this state into another value. There is basic memoization here on references. */\n  map<U>(mapper: (t: T) => U): Watchable<U> {\n    // Keep a memoized version if mapper is expensive, we also want to\n    // keep reference equality between getValue calls.\n    const memoizedMapper = memoizeLatest(mapper);\n    return new DerivedWatchable<U>({\n      hasValue: () => this.hasValue(),\n      getValue: () => memoizedMapper(this.getValue()),\n      watch: (watcher) => this.watch((v) => watcher(memoizedMapper(v))),\n    });\n  }\n\n  /*\n   * Returns a watchable that allows for callbacks when the first subscription is setup\n   * and the last watcher is torn down.\n   *\n   * Useful for tracking usage of a watchable or needing side effects when updates come in.\n   */\n  withHooks({\n    setup,\n    tearDown,\n  }: {\n    setup(): void;\n    tearDown(): void;\n  }): Watchable<T> {\n    let count = 0;\n    return new DerivedWatchable({\n      hasValue: () => this.hasValue(),\n      getValue: () => this.getValue(),\n      watch: (watch: WatcherFn<T>) => {\n        const isFirst = count === 0;\n        count++;\n        const unsub = this.watch(watch);\n        if (isFirst) {\n          setup();\n        }\n        return () => {\n          unsub();\n          count--;\n          if (count === 0) {\n            tearDown();\n          }\n        };\n      },\n    });\n  }\n\n  /* Convert the watchable into a promise that resolves when the watchable is not empty. */\n  toPromise(): Promise<T> {\n    return new Promise((resolve) => {\n      let resolved = false;\n      let unsub: Unsubscribe | null = null;\n      unsub = this.watch((v) => {\n        resolve(v);\n        // If unsub is unset then this watch fired synchronously and we just flag that\n        // this happened, otherwise we need to unsub async when the watch finally resolves.\n        if (unsub) {\n          unsub();\n        } else {\n          resolved = true;\n        }\n      });\n      if (resolved) unsub();\n    });\n  }\n\n  /** Returns either the current value as a watchable or a watchable that is empty and only updates once. */\n  snapshot(): Watchable<T> {\n    if (this.hasValue()) {\n      return WatchableSubject.of(this.getValue());\n    }\n    const delayed = WatchableSubject.empty<T>();\n    this.toPromise().then((v) => delayed.update(v));\n    return delayed;\n  }\n}\n\nclass DerivedWatchable<T> extends Watchable<T> {\n  constructor(private readonly source: WatchableLike<T>) {\n    super();\n  }\n\n  hasValue(): boolean {\n    return this.source.hasValue();\n  }\n\n  getValue(): T {\n    return this.source.getValue();\n  }\n\n  watch(watcher: WatcherFn<T>): Unsubscribe {\n    return this.source.watch(watcher);\n  }\n}\n\nclass EmptyWatchableError extends Error {\n  constructor() {\n    super('You must check hasValue() before accessing a watchable value.');\n  }\n}\n\n/** The mutable version of a watchable. */\nexport class WatchableSubject<T> extends Watchable<T> {\n  private readonly subscriptions = new Subscriptions<WatcherFn<T>>();\n\n  private currentValue: Box<T> | null = null;\n\n  private constructor(currentValue: Box<T> | null) {\n    super();\n    this.currentValue = currentValue;\n  }\n\n  hasValue(): boolean {\n    return this.currentValue !== null;\n  }\n\n  getValue(): T {\n    if (!this.currentValue) {\n      throw new EmptyWatchableError();\n    }\n    return this.currentValue.current;\n  }\n\n  static empty<T>() {\n    return new WatchableSubject<T>(null);\n  }\n\n  static of<T>(value: T) {\n    return new WatchableSubject<T>({ current: value });\n  }\n\n  /* Update the current value for this \"watchable\". Does memoization on references. */\n  update(elem: T): void {\n    if (this.currentValue && this.currentValue.current === elem) return;\n    this.currentValue = { current: elem };\n    this.subscriptions.forEach((cb) => cb(elem));\n  }\n\n  watch(watch: WatcherFn<T>): Unsubscribe {\n    const unsub = this.subscriptions.add(watch);\n    // Fire off the initial value synchronously.\n    if (this.hasValue()) watch(this.getValue());\n    return unsub;\n  }\n}\n\n/*\n * Combines a map from keys to watchables, and omits any watchables that don't have a value defined in the result.\n */\nexport function partialCombineWatchable<K, V>(\n  map: ReadonlyMap<K, Watchable<V>>\n): Watchable<Map<K, V>> {\n  if (map.size === 0) {\n    return WatchableSubject.of(new Map());\n  }\n\n  const subject = WatchableSubject.empty<Map<K, V>>();\n\n  // Make a copy in case someone mutates the map\n  const mapCopy = new Map(map);\n\n  const calculateLatest = () => {\n    const latest = new Map<K, V>();\n    mapCopy.forEach((watchable, key) => {\n      if (watchable.hasValue()) {\n        latest.set(key, watchable.getValue());\n      }\n    });\n    return latest;\n  };\n\n  const updateLatest = () => {\n    const latest = calculateLatest();\n    const previous = subject.getOrDefault(new Map<K, V>());\n    for (const [key, value] of latest.entries()) {\n      if (previous.get(key) !== value) {\n        subject.update(latest);\n        return;\n      }\n    }\n    // Note, there can never be missing keys since a watchable can never go from having a value to not having a value.\n    return;\n  };\n\n  const startWatching = (watch: WatcherFn<Map<K, V>>) => {\n    const unsubscribes: Unsubscribe[] = [];\n\n    // started is set to false during subscribing, so we don't update the map on the start of\n    // every watchable, which has O(N^2) behavior. Instead we wait until all subscriptions have started\n    // and *then* calculate the map at the end once.\n    let started = false;\n    mapCopy.forEach((watchable) => {\n      unsubscribes.push(\n        watchable.watch(() => {\n          if (!started) return;\n          updateLatest();\n        })\n      );\n    });\n    started = true;\n    const unsubscribeSubject = subject.watch(watch);\n\n    return () => {\n      unsubscribeSubject();\n      for (const unsub of unsubscribes) {\n        unsub();\n      }\n    };\n  };\n\n  updateLatest();\n\n  return new DerivedWatchable({\n    hasValue: () => subject.hasValue(),\n    getValue: () => subject.getValue(),\n    watch: (watch: WatcherFn<Map<K, V>>) => startWatching(watch),\n  });\n}\n","import { DependencyList, useEffect, useMemo, useState } from 'react';\n\nimport { Watchable } from './watchable';\n\n/*\n * A combination of useMemo and useWatchable for simple usage.\n *\n * It's suggested that this is listed as a custom hook for eslint's react-hooks plugin.\n *  Learn more: https://www.npmjs.com/package/eslint-plugin-react-hooks#user-content-advanced-configuration\n */\nexport function useMemoizedWatchable<T>(\n  w: () => Watchable<T>,\n  deps: DependencyList\n): T | null {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return useWatchable(useMemo(w, deps));\n}\n\n/*\n * A hook to extract a value from a watchable. If the watchable is empty than `null` is emitted.\n */\nexport function useWatchable<T>(w: Watchable<T>): T | null {\n  return useExplicitWatchable(null, w);\n}\n\n/*\n * Similar to `useWatchable` except that it allows the loading value to be customized.\n */\nexport function useExplicitWatchable<D, T>(loading: D, w: Watchable<T>): D | T {\n  const [value, setValue] = useState<D | T>(\n    w.hasValue() ? w.getValue() : loading\n  );\n  useEffect(() => w.watch(setValue), [w]);\n  return value;\n}\n"],"names":["Subscriptions","callbacks","Set","add","fn","has","Error","hadValue","isEmpty","size","forEach","callback","Array","from","memoizeLatest","latest","input","output","Watchable","getOrDefault","defaultValue","hasValue","getValue","map","mapper","memoizedMapper","DerivedWatchable","watch","watcher","v","withHooks","setup","tearDown","count","isFirst","unsub","toPromise","Promise","resolve","resolved","snapshot","WatchableSubject","of","delayed","empty","then","update","source","EmptyWatchableError","currentValue","subscriptions","current","value","elem","cb","partialCombineWatchable","Map","subject","mapCopy","calculateLatest","watchable","key","set","updateLatest","previous","entries","get","startWatching","unsubscribes","started","push","unsubscribeSubject","useMemoizedWatchable","w","deps","useWatchable","useMemo","useExplicitWatchable","loading","useState","setValue","useEffect"],"mappings":"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"}