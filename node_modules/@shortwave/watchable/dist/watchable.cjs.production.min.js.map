{"version":3,"file":"watchable.cjs.production.min.js","sources":["../src/utils.ts","../src/watchable.ts","../src/hooks.ts"],"sourcesContent":["export interface Box<T> {\n  current: T;\n}\n\nexport type Unsubscribe = () => void;\n\nexport class Subscriptions<CallbackType> {\n  private callbacks = new Set<CallbackType>();\n\n  add(fn: CallbackType): Unsubscribe {\n    if (this.callbacks.has(fn)) {\n      throw new Error(\"Can't add subscription twice!\");\n    }\n    this.callbacks.add(fn);\n    return () => {\n      const hadValue = this.callbacks.delete(fn);\n      if (!hadValue) {\n        throw new Error('Did not find callback function for unsubscribe');\n      }\n    };\n  }\n\n  isEmpty(): boolean {\n    return this.callbacks.size === 0;\n  }\n\n  forEach(callback: (cb: CallbackType) => void): void {\n    // Make a copy to support sync removal.\n    return Array.from(this.callbacks).forEach(callback);\n  }\n}\n\nexport function memoizeLatest<Input, Output>(\n  fn: (i: Input) => Output\n): (i: Input) => Output {\n  let latest: { input: Input; output: Output } | null = null;\n  return (input) => {\n    if (!latest) {\n      latest = { input, output: fn(input) };\n    } else if (latest.input !== input) {\n      latest.input = input;\n      latest.output = fn(input);\n    }\n    return latest.output;\n  };\n}\n\nexport interface MapLike<K, V> {\n  get(key: K): V | undefined;\n  set(key: K, value: V): void;\n  has(k: K): boolean;\n  readonly size: number;\n  [Symbol.iterator](): IterableIterator<[K, V]>;\n  keys(): IterableIterator<K>;\n  values(): IterableIterator<V>;\n}\n\nexport type MapFactory<K, V> = () => Map<K, V>;\n\nexport function defaultMapFactory<K, V>(): Map<K, V> {\n  return new Map();\n}\n","import { Subscriptions, Unsubscribe, Box, memoizeLatest } from './utils';\n\nexport type WatcherFn<T> = (value: T) => void;\n\ninterface WatchableLike<T> {\n  /** If this watchable has a current value. */\n  hasValue(): boolean;\n  /** Get the current value for this watchable, requires `hasValue` returns true. */\n  getValue(): T;\n\n  /** Watch this for updates. The current value will be replayed here. */\n  watch(watch: WatcherFn<T>): Unsubscribe;\n}\n\nexport abstract class Watchable<T> implements WatchableLike<T> {\n  abstract hasValue(): boolean;\n  abstract getValue(): T;\n  getOrDefault<V>(defaultValue: V): T | V {\n    return this.hasValue() ? this.getValue() : defaultValue;\n  }\n\n  abstract watch(watcher: WatcherFn<T>): Unsubscribe;\n\n  /* Transform this state into another value. There is basic memoization here on references. */\n  map<U>(mapper: (t: T) => U): Watchable<U> {\n    // Keep a memoized version if mapper is expensive, we also want to\n    // keep reference equality between getValue calls.\n    const memoizedMapper = memoizeLatest(mapper);\n    return new DerivedWatchable<U>({\n      hasValue: () => this.hasValue(),\n      getValue: () => memoizedMapper(this.getValue()),\n      watch: (watcher) => this.watch((v) => watcher(memoizedMapper(v))),\n    });\n  }\n\n  /*\n   * Returns a watchable that allows for callbacks when the first subscription is setup\n   * and the last watcher is torn down.\n   *\n   * Useful for tracking usage of a watchable or needing side effects when updates come in.\n   */\n  withHooks({\n    setup,\n    tearDown,\n  }: {\n    setup(): void;\n    tearDown(): void;\n  }): Watchable<T> {\n    let count = 0;\n    return new DerivedWatchable({\n      hasValue: () => this.hasValue(),\n      getValue: () => this.getValue(),\n      watch: (watch: WatcherFn<T>) => {\n        const isFirst = count === 0;\n        count++;\n        const unsub = this.watch(watch);\n        if (isFirst) {\n          setup();\n        }\n        return () => {\n          unsub();\n          count--;\n          if (count === 0) {\n            tearDown();\n          }\n        };\n      },\n    });\n  }\n\n  /* Convert the watchable into a promise that resolves when the watchable is not empty. */\n  toPromise(): Promise<T> {\n    return new Promise((resolve) => {\n      let resolved = false;\n      let unsub: Unsubscribe | null = null;\n      unsub = this.watch((v) => {\n        resolve(v);\n        // If unsub is unset then this watch fired synchronously and we just flag that\n        // this happened, otherwise we need to unsub async when the watch finally resolves.\n        if (unsub) {\n          unsub();\n        } else {\n          resolved = true;\n        }\n      });\n      if (resolved) unsub();\n    });\n  }\n\n  /** Returns either the current value as a watchable or a watchable that is empty and only updates once. */\n  snapshot(): Watchable<T> {\n    if (this.hasValue()) {\n      return WatchableSubject.of(this.getValue());\n    }\n    const delayed = WatchableSubject.empty<T>();\n    this.toPromise().then((v) => delayed.update(v));\n    return delayed;\n  }\n}\n\nclass DerivedWatchable<T> extends Watchable<T> {\n  constructor(private readonly source: WatchableLike<T>) {\n    super();\n  }\n\n  hasValue(): boolean {\n    return this.source.hasValue();\n  }\n\n  getValue(): T {\n    return this.source.getValue();\n  }\n\n  watch(watcher: WatcherFn<T>): Unsubscribe {\n    return this.source.watch(watcher);\n  }\n}\n\nclass EmptyWatchableError extends Error {\n  constructor() {\n    super('You must check hasValue() before accessing a watchable value.');\n  }\n}\n\n/** The mutable version of a watchable. */\nexport class WatchableSubject<T> extends Watchable<T> {\n  private readonly subscriptions = new Subscriptions<WatcherFn<T>>();\n\n  private currentValue: Box<T> | null = null;\n\n  private constructor(currentValue: Box<T> | null) {\n    super();\n    this.currentValue = currentValue;\n  }\n\n  hasValue(): boolean {\n    return this.currentValue !== null;\n  }\n\n  getValue(): T {\n    if (!this.currentValue) {\n      throw new EmptyWatchableError();\n    }\n    return this.currentValue.current;\n  }\n\n  static empty<T>() {\n    return new WatchableSubject<T>(null);\n  }\n\n  static of<T>(value: T) {\n    return new WatchableSubject<T>({ current: value });\n  }\n\n  /* Update the current value for this \"watchable\". Does memoization on references. */\n  update(elem: T): void {\n    if (this.currentValue && this.currentValue.current === elem) return;\n    this.currentValue = { current: elem };\n    this.subscriptions.forEach((cb) => cb(elem));\n  }\n\n  watch(watch: WatcherFn<T>): Unsubscribe {\n    const unsub = this.subscriptions.add(watch);\n    // Fire off the initial value synchronously.\n    if (this.hasValue()) watch(this.getValue());\n    return unsub;\n  }\n}\n\n/*\n * Combines a map from keys to watchables, and omits any watchables that don't have a value defined in the result.\n */\nexport function partialCombineWatchable<K, V>(\n  map: ReadonlyMap<K, Watchable<V>>\n): Watchable<Map<K, V>> {\n  if (map.size === 0) {\n    return WatchableSubject.of(new Map());\n  }\n\n  const subject = WatchableSubject.empty<Map<K, V>>();\n\n  // Make a copy in case someone mutates the map\n  const mapCopy = new Map(map);\n\n  const calculateLatest = () => {\n    const latest = new Map<K, V>();\n    mapCopy.forEach((watchable, key) => {\n      if (watchable.hasValue()) {\n        latest.set(key, watchable.getValue());\n      }\n    });\n    return latest;\n  };\n\n  const updateLatest = () => {\n    const latest = calculateLatest();\n    const previous = subject.getOrDefault(new Map<K, V>());\n    for (const [key, value] of latest.entries()) {\n      if (previous.get(key) !== value) {\n        subject.update(latest);\n        return;\n      }\n    }\n    // Note, there can never be missing keys since a watchable can never go from having a value to not having a value.\n    return;\n  };\n\n  const startWatching = (watch: WatcherFn<Map<K, V>>) => {\n    const unsubscribes: Unsubscribe[] = [];\n\n    // started is set to false during subscribing, so we don't update the map on the start of\n    // every watchable, which has O(N^2) behavior. Instead we wait until all subscriptions have started\n    // and *then* calculate the map at the end once.\n    let started = false;\n    mapCopy.forEach((watchable) => {\n      unsubscribes.push(\n        watchable.watch(() => {\n          if (!started) return;\n          updateLatest();\n        })\n      );\n    });\n    started = true;\n    const unsubscribeSubject = subject.watch(watch);\n\n    return () => {\n      unsubscribeSubject();\n      for (const unsub of unsubscribes) {\n        unsub();\n      }\n    };\n  };\n\n  updateLatest();\n\n  return new DerivedWatchable({\n    hasValue: () => subject.hasValue(),\n    getValue: () => subject.getValue(),\n    watch: (watch: WatcherFn<Map<K, V>>) => startWatching(watch),\n  });\n}\n","import { DependencyList, useEffect, useMemo, useState } from 'react';\n\nimport { Watchable } from './watchable';\n\n/*\n * A combination of useMemo and useWatchable for simple usage.\n *\n * It's suggested that this is listed as a custom hook for eslint's react-hooks plugin.\n *  Learn more: https://www.npmjs.com/package/eslint-plugin-react-hooks#user-content-advanced-configuration\n */\nexport function useMemoizedWatchable<T>(\n  w: () => Watchable<T>,\n  deps: DependencyList\n): T | null {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return useWatchable(useMemo(w, deps));\n}\n\n/*\n * A hook to extract a value from a watchable. If the watchable is empty than `null` is emitted.\n */\nexport function useWatchable<T>(w: Watchable<T>): T | null {\n  return useExplicitWatchable(null, w);\n}\n\n/*\n * Similar to `useWatchable` except that it allows the loading value to be customized.\n */\nexport function useExplicitWatchable<D, T>(loading: D, w: Watchable<T>): D | T {\n  const [value, setValue] = useState<D | T>(\n    w.hasValue() ? w.getValue() : loading\n  );\n  useEffect(() => w.watch(setValue), [w]);\n  return value;\n}\n"],"names":["Subscriptions","callbacks","Set","add","fn","this","has","Error","_this","isEmpty","size","forEach","callback","Array","from","Watchable","getOrDefault","defaultValue","hasValue","getValue","map","mapper","latest","memoizedMapper","input","output","DerivedWatchable","watch","watcher","v","withHooks","setup","tearDown","count","_this2","isFirst","unsub","toPromise","Promise","resolve","resolved","_this3","snapshot","WatchableSubject","of","delayed","empty","then","update","source","EmptyWatchableError","_Error","currentValue","subscriptions","current","value","elem","cb","useWatchable","w","useExplicitWatchable","loading","useState","setValue","useEffect","Map","subject","mapCopy","updateLatest","watchable","key","set","calculateLatest","previous","entries","get","unsubscribes","started","push","unsubscribeSubject","startWatching","deps","useMemo"],"mappings":"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"}