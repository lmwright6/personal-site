import { useMemo, useState, useEffect } from 'react';

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var Subscriptions = /*#__PURE__*/function () {
  function Subscriptions() {
    this.callbacks = new Set();
  }

  var _proto = Subscriptions.prototype;

  _proto.add = function add(fn) {
    var _this = this;

    if (this.callbacks.has(fn)) {
      throw new Error("Can't add subscription twice!");
    }

    this.callbacks.add(fn);
    return function () {
      var hadValue = _this.callbacks["delete"](fn);

      if (!hadValue) {
        throw new Error('Did not find callback function for unsubscribe');
      }
    };
  };

  _proto.isEmpty = function isEmpty() {
    return this.callbacks.size === 0;
  };

  _proto.forEach = function forEach(callback) {
    // Make a copy to support sync removal.
    return Array.from(this.callbacks).forEach(callback);
  };

  return Subscriptions;
}();
function memoizeLatest(fn) {
  var latest = null;
  return function (input) {
    if (!latest) {
      latest = {
        input: input,
        output: fn(input)
      };
    } else if (latest.input !== input) {
      latest.input = input;
      latest.output = fn(input);
    }

    return latest.output;
  };
}

var Watchable = /*#__PURE__*/function () {
  function Watchable() {}

  var _proto = Watchable.prototype;

  _proto.getOrDefault = function getOrDefault(defaultValue) {
    return this.hasValue() ? this.getValue() : defaultValue;
  }
  /* Transform this state into another value. There is basic memoization here on references. */
  ;

  _proto.map = function map(mapper) {
    var _this = this;

    // Keep a memoized version if mapper is expensive, we also want to
    // keep reference equality between getValue calls.
    var memoizedMapper = memoizeLatest(mapper);
    return new DerivedWatchable({
      hasValue: function hasValue() {
        return _this.hasValue();
      },
      getValue: function getValue() {
        return memoizedMapper(_this.getValue());
      },
      watch: function watch(watcher) {
        return _this.watch(function (v) {
          return watcher(memoizedMapper(v));
        });
      }
    });
  }
  /*
   * Returns a watchable that allows for callbacks when the first subscription is setup
   * and the last watcher is torn down.
   *
   * Useful for tracking usage of a watchable or needing side effects when updates come in.
   */
  ;

  _proto.withHooks = function withHooks(_ref) {
    var _this2 = this;

    var setup = _ref.setup,
        tearDown = _ref.tearDown;
    var count = 0;
    return new DerivedWatchable({
      hasValue: function hasValue() {
        return _this2.hasValue();
      },
      getValue: function getValue() {
        return _this2.getValue();
      },
      watch: function watch(_watch) {
        var isFirst = count === 0;
        count++;

        var unsub = _this2.watch(_watch);

        if (isFirst) {
          setup();
        }

        return function () {
          unsub();
          count--;

          if (count === 0) {
            tearDown();
          }
        };
      }
    });
  }
  /* Convert the watchable into a promise that resolves when the watchable is not empty. */
  ;

  _proto.toPromise = function toPromise() {
    var _this3 = this;

    return new Promise(function (resolve) {
      var resolved = false;
      var unsub = null;
      unsub = _this3.watch(function (v) {
        resolve(v); // If unsub is unset then this watch fired synchronously and we just flag that
        // this happened, otherwise we need to unsub async when the watch finally resolves.

        if (unsub) {
          unsub();
        } else {
          resolved = true;
        }
      });
      if (resolved) unsub();
    });
  }
  /** Returns either the current value as a watchable or a watchable that is empty and only updates once. */
  ;

  _proto.snapshot = function snapshot() {
    if (this.hasValue()) {
      return WatchableSubject.of(this.getValue());
    }

    var delayed = WatchableSubject.empty();
    this.toPromise().then(function (v) {
      return delayed.update(v);
    });
    return delayed;
  };

  return Watchable;
}();

var DerivedWatchable = /*#__PURE__*/function (_Watchable) {
  _inheritsLoose(DerivedWatchable, _Watchable);

  function DerivedWatchable(source) {
    var _this4;

    _this4 = _Watchable.call(this) || this;
    _this4.source = void 0;
    _this4.source = source;
    return _this4;
  }

  var _proto2 = DerivedWatchable.prototype;

  _proto2.hasValue = function hasValue() {
    return this.source.hasValue();
  };

  _proto2.getValue = function getValue() {
    return this.source.getValue();
  };

  _proto2.watch = function watch(watcher) {
    return this.source.watch(watcher);
  };

  return DerivedWatchable;
}(Watchable);

var EmptyWatchableError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(EmptyWatchableError, _Error);

  function EmptyWatchableError() {
    return _Error.call(this, 'You must check hasValue() before accessing a watchable value.') || this;
  }

  return EmptyWatchableError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/** The mutable version of a watchable. */


var WatchableSubject = /*#__PURE__*/function (_Watchable2) {
  _inheritsLoose(WatchableSubject, _Watchable2);

  function WatchableSubject(currentValue) {
    var _this5;

    _this5 = _Watchable2.call(this) || this;
    _this5.subscriptions = new Subscriptions();
    _this5.currentValue = null;
    _this5.currentValue = currentValue;
    return _this5;
  }

  var _proto3 = WatchableSubject.prototype;

  _proto3.hasValue = function hasValue() {
    return this.currentValue !== null;
  };

  _proto3.getValue = function getValue() {
    if (!this.currentValue) {
      throw new EmptyWatchableError();
    }

    return this.currentValue.current;
  };

  WatchableSubject.empty = function empty() {
    return new WatchableSubject(null);
  };

  WatchableSubject.of = function of(value) {
    return new WatchableSubject({
      current: value
    });
  }
  /* Update the current value for this "watchable". Does memoization on references. */
  ;

  _proto3.update = function update(elem) {
    if (this.currentValue && this.currentValue.current === elem) return;
    this.currentValue = {
      current: elem
    };
    this.subscriptions.forEach(function (cb) {
      return cb(elem);
    });
  };

  _proto3.watch = function watch(_watch2) {
    var unsub = this.subscriptions.add(_watch2); // Fire off the initial value synchronously.

    if (this.hasValue()) _watch2(this.getValue());
    return unsub;
  };

  return WatchableSubject;
}(Watchable);
/*
 * Combines a map from keys to watchables, and omits any watchables that don't have a value defined in the result.
 */

function partialCombineWatchable(map) {
  if (map.size === 0) {
    return WatchableSubject.of(new Map());
  }

  var subject = WatchableSubject.empty(); // Make a copy in case someone mutates the map

  var mapCopy = new Map(map);

  var calculateLatest = function calculateLatest() {
    var latest = new Map();
    mapCopy.forEach(function (watchable, key) {
      if (watchable.hasValue()) {
        latest.set(key, watchable.getValue());
      }
    });
    return latest;
  };

  var updateLatest = function updateLatest() {
    var latest = calculateLatest();
    var previous = subject.getOrDefault(new Map());

    for (var _iterator = _createForOfIteratorHelperLoose(latest.entries()), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          key = _step$value[0],
          value = _step$value[1];

      if (previous.get(key) !== value) {
        subject.update(latest);
        return;
      }
    } // Note, there can never be missing keys since a watchable can never go from having a value to not having a value.


    return;
  };

  var startWatching = function startWatching(watch) {
    var unsubscribes = []; // started is set to false during subscribing, so we don't update the map on the start of
    // every watchable, which has O(N^2) behavior. Instead we wait until all subscriptions have started
    // and *then* calculate the map at the end once.

    var started = false;
    mapCopy.forEach(function (watchable) {
      unsubscribes.push(watchable.watch(function () {
        if (!started) return;
        updateLatest();
      }));
    });
    started = true;
    var unsubscribeSubject = subject.watch(watch);
    return function () {
      unsubscribeSubject();

      for (var _iterator2 = _createForOfIteratorHelperLoose(unsubscribes), _step2; !(_step2 = _iterator2()).done;) {
        var unsub = _step2.value;
        unsub();
      }
    };
  };

  updateLatest();
  return new DerivedWatchable({
    hasValue: function hasValue() {
      return subject.hasValue();
    },
    getValue: function getValue() {
      return subject.getValue();
    },
    watch: function watch(_watch3) {
      return startWatching(_watch3);
    }
  });
}

/*
 * A combination of useMemo and useWatchable for simple usage.
 *
 * It's suggested that this is listed as a custom hook for eslint's react-hooks plugin.
 *  Learn more: https://www.npmjs.com/package/eslint-plugin-react-hooks#user-content-advanced-configuration
 */

function useMemoizedWatchable(w, deps) {
  // eslint-disable-next-line react-hooks/exhaustive-deps
  return useWatchable(useMemo(w, deps));
}
/*
 * A hook to extract a value from a watchable. If the watchable is empty than `null` is emitted.
 */

function useWatchable(w) {
  return useExplicitWatchable(null, w);
}
/*
 * Similar to `useWatchable` except that it allows the loading value to be customized.
 */

function useExplicitWatchable(loading, w) {
  var _useState = useState(w.hasValue() ? w.getValue() : loading),
      value = _useState[0],
      setValue = _useState[1];

  useEffect(function () {
    return w.watch(setValue);
  }, [w]);
  return value;
}

export { Watchable, WatchableSubject, partialCombineWatchable, useExplicitWatchable, useMemoizedWatchable, useWatchable };
//# sourceMappingURL=watchable.esm.js.map
