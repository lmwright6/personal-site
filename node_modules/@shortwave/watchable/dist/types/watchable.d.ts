import { Unsubscribe } from './utils';
export declare type WatcherFn<T> = (value: T) => void;
interface WatchableLike<T> {
    /** If this watchable has a current value. */
    hasValue(): boolean;
    /** Get the current value for this watchable, requires `hasValue` returns true. */
    getValue(): T;
    /** Watch this for updates. The current value will be replayed here. */
    watch(watch: WatcherFn<T>): Unsubscribe;
}
export declare abstract class Watchable<T> implements WatchableLike<T> {
    abstract hasValue(): boolean;
    abstract getValue(): T;
    getOrDefault<V>(defaultValue: V): T | V;
    abstract watch(watcher: WatcherFn<T>): Unsubscribe;
    map<U>(mapper: (t: T) => U): Watchable<U>;
    withHooks({ setup, tearDown, }: {
        setup(): void;
        tearDown(): void;
    }): Watchable<T>;
    toPromise(): Promise<T>;
    /** Returns either the current value as a watchable or a watchable that is empty and only updates once. */
    snapshot(): Watchable<T>;
}
/** The mutable version of a watchable. */
export declare class WatchableSubject<T> extends Watchable<T> {
    private readonly subscriptions;
    private currentValue;
    private constructor();
    hasValue(): boolean;
    getValue(): T;
    static empty<T>(): WatchableSubject<T>;
    static of<T>(value: T): WatchableSubject<T>;
    update(elem: T): void;
    watch(watch: WatcherFn<T>): Unsubscribe;
}
export declare function partialCombineWatchable<K, V>(map: ReadonlyMap<K, Watchable<V>>): Watchable<Map<K, V>>;
export {};
