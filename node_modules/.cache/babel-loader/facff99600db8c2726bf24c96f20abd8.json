{"ast":null,"code":"import { useMemo, useState, useEffect } from 'react';\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar Subscriptions = /*#__PURE__*/function () {\n  function Subscriptions() {\n    this.callbacks = new Set();\n  }\n\n  var _proto = Subscriptions.prototype;\n\n  _proto.add = function add(fn) {\n    var _this = this;\n\n    if (this.callbacks.has(fn)) {\n      throw new Error(\"Can't add subscription twice!\");\n    }\n\n    this.callbacks.add(fn);\n    return function () {\n      var hadValue = _this.callbacks[\"delete\"](fn);\n\n      if (!hadValue) {\n        throw new Error('Did not find callback function for unsubscribe');\n      }\n    };\n  };\n\n  _proto.isEmpty = function isEmpty() {\n    return this.callbacks.size === 0;\n  };\n\n  _proto.forEach = function forEach(callback) {\n    // Make a copy to support sync removal.\n    return Array.from(this.callbacks).forEach(callback);\n  };\n\n  return Subscriptions;\n}();\n\nfunction memoizeLatest(fn) {\n  var latest = null;\n  return function (input) {\n    if (!latest) {\n      latest = {\n        input: input,\n        output: fn(input)\n      };\n    } else if (latest.input !== input) {\n      latest.input = input;\n      latest.output = fn(input);\n    }\n\n    return latest.output;\n  };\n}\n\nvar Watchable = /*#__PURE__*/function () {\n  function Watchable() {}\n\n  var _proto = Watchable.prototype;\n\n  _proto.getOrDefault = function getOrDefault(defaultValue) {\n    return this.hasValue() ? this.getValue() : defaultValue;\n  }\n  /* Transform this state into another value. There is basic memoization here on references. */\n  ;\n\n  _proto.map = function map(mapper) {\n    var _this = this; // Keep a memoized version if mapper is expensive, we also want to\n    // keep reference equality between getValue calls.\n\n\n    var memoizedMapper = memoizeLatest(mapper);\n    return new DerivedWatchable({\n      hasValue: function hasValue() {\n        return _this.hasValue();\n      },\n      getValue: function getValue() {\n        return memoizedMapper(_this.getValue());\n      },\n      watch: function watch(watcher) {\n        return _this.watch(function (v) {\n          return watcher(memoizedMapper(v));\n        });\n      }\n    });\n  }\n  /*\r\n   * Returns a watchable that allows for callbacks when the first subscription is setup\r\n   * and the last watcher is torn down.\r\n   *\r\n   * Useful for tracking usage of a watchable or needing side effects when updates come in.\r\n   */\n  ;\n\n  _proto.withHooks = function withHooks(_ref) {\n    var _this2 = this;\n\n    var setup = _ref.setup,\n        tearDown = _ref.tearDown;\n    var count = 0;\n    return new DerivedWatchable({\n      hasValue: function hasValue() {\n        return _this2.hasValue();\n      },\n      getValue: function getValue() {\n        return _this2.getValue();\n      },\n      watch: function watch(_watch) {\n        var isFirst = count === 0;\n        count++;\n\n        var unsub = _this2.watch(_watch);\n\n        if (isFirst) {\n          setup();\n        }\n\n        return function () {\n          unsub();\n          count--;\n\n          if (count === 0) {\n            tearDown();\n          }\n        };\n      }\n    });\n  }\n  /* Convert the watchable into a promise that resolves when the watchable is not empty. */\n  ;\n\n  _proto.toPromise = function toPromise() {\n    var _this3 = this;\n\n    return new Promise(function (resolve) {\n      var resolved = false;\n      var unsub = null;\n      unsub = _this3.watch(function (v) {\n        resolve(v); // If unsub is unset then this watch fired synchronously and we just flag that\n        // this happened, otherwise we need to unsub async when the watch finally resolves.\n\n        if (unsub) {\n          unsub();\n        } else {\n          resolved = true;\n        }\n      });\n      if (resolved) unsub();\n    });\n  }\n  /** Returns either the current value as a watchable or a watchable that is empty and only updates once. */\n  ;\n\n  _proto.snapshot = function snapshot() {\n    if (this.hasValue()) {\n      return WatchableSubject.of(this.getValue());\n    }\n\n    var delayed = WatchableSubject.empty();\n    this.toPromise().then(function (v) {\n      return delayed.update(v);\n    });\n    return delayed;\n  };\n\n  return Watchable;\n}();\n\nvar DerivedWatchable = /*#__PURE__*/function (_Watchable) {\n  _inheritsLoose(DerivedWatchable, _Watchable);\n\n  function DerivedWatchable(source) {\n    var _this4;\n\n    _this4 = _Watchable.call(this) || this;\n    _this4.source = void 0;\n    _this4.source = source;\n    return _this4;\n  }\n\n  var _proto2 = DerivedWatchable.prototype;\n\n  _proto2.hasValue = function hasValue() {\n    return this.source.hasValue();\n  };\n\n  _proto2.getValue = function getValue() {\n    return this.source.getValue();\n  };\n\n  _proto2.watch = function watch(watcher) {\n    return this.source.watch(watcher);\n  };\n\n  return DerivedWatchable;\n}(Watchable);\n\nvar EmptyWatchableError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(EmptyWatchableError, _Error);\n\n  function EmptyWatchableError() {\n    return _Error.call(this, 'You must check hasValue() before accessing a watchable value.') || this;\n  }\n\n  return EmptyWatchableError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/** The mutable version of a watchable. */\n\n\nvar WatchableSubject = /*#__PURE__*/function (_Watchable2) {\n  _inheritsLoose(WatchableSubject, _Watchable2);\n\n  function WatchableSubject(currentValue) {\n    var _this5;\n\n    _this5 = _Watchable2.call(this) || this;\n    _this5.subscriptions = new Subscriptions();\n    _this5.currentValue = null;\n    _this5.currentValue = currentValue;\n    return _this5;\n  }\n\n  var _proto3 = WatchableSubject.prototype;\n\n  _proto3.hasValue = function hasValue() {\n    return this.currentValue !== null;\n  };\n\n  _proto3.getValue = function getValue() {\n    if (!this.currentValue) {\n      throw new EmptyWatchableError();\n    }\n\n    return this.currentValue.current;\n  };\n\n  WatchableSubject.empty = function empty() {\n    return new WatchableSubject(null);\n  };\n\n  WatchableSubject.of = function of(value) {\n    return new WatchableSubject({\n      current: value\n    });\n  }\n  /* Update the current value for this \"watchable\". Does memoization on references. */\n  ;\n\n  _proto3.update = function update(elem) {\n    if (this.currentValue && this.currentValue.current === elem) return;\n    this.currentValue = {\n      current: elem\n    };\n    this.subscriptions.forEach(function (cb) {\n      return cb(elem);\n    });\n  };\n\n  _proto3.watch = function watch(_watch2) {\n    var unsub = this.subscriptions.add(_watch2); // Fire off the initial value synchronously.\n\n    if (this.hasValue()) _watch2(this.getValue());\n    return unsub;\n  };\n\n  return WatchableSubject;\n}(Watchable);\n/*\r\n * Combines a map from keys to watchables, and omits any watchables that don't have a value defined in the result.\r\n */\n\n\nfunction partialCombineWatchable(map) {\n  if (map.size === 0) {\n    return WatchableSubject.of(new Map());\n  }\n\n  var subject = WatchableSubject.empty(); // Make a copy in case someone mutates the map\n\n  var mapCopy = new Map(map);\n\n  var calculateLatest = function calculateLatest() {\n    var latest = new Map();\n    mapCopy.forEach(function (watchable, key) {\n      if (watchable.hasValue()) {\n        latest.set(key, watchable.getValue());\n      }\n    });\n    return latest;\n  };\n\n  var updateLatest = function updateLatest() {\n    var latest = calculateLatest();\n    var previous = subject.getOrDefault(new Map());\n\n    for (var _iterator = _createForOfIteratorHelperLoose(latest.entries()), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          key = _step$value[0],\n          value = _step$value[1];\n\n      if (previous.get(key) !== value) {\n        subject.update(latest);\n        return;\n      }\n    } // Note, there can never be missing keys since a watchable can never go from having a value to not having a value.\n\n\n    return;\n  };\n\n  var startWatching = function startWatching(watch) {\n    var unsubscribes = []; // started is set to false during subscribing, so we don't update the map on the start of\n    // every watchable, which has O(N^2) behavior. Instead we wait until all subscriptions have started\n    // and *then* calculate the map at the end once.\n\n    var started = false;\n    mapCopy.forEach(function (watchable) {\n      unsubscribes.push(watchable.watch(function () {\n        if (!started) return;\n        updateLatest();\n      }));\n    });\n    started = true;\n    var unsubscribeSubject = subject.watch(watch);\n    return function () {\n      unsubscribeSubject();\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(unsubscribes), _step2; !(_step2 = _iterator2()).done;) {\n        var unsub = _step2.value;\n        unsub();\n      }\n    };\n  };\n\n  updateLatest();\n  return new DerivedWatchable({\n    hasValue: function hasValue() {\n      return subject.hasValue();\n    },\n    getValue: function getValue() {\n      return subject.getValue();\n    },\n    watch: function watch(_watch3) {\n      return startWatching(_watch3);\n    }\n  });\n}\n/*\r\n * A combination of useMemo and useWatchable for simple usage.\r\n *\r\n * It's suggested that this is listed as a custom hook for eslint's react-hooks plugin.\r\n *  Learn more: https://www.npmjs.com/package/eslint-plugin-react-hooks#user-content-advanced-configuration\r\n */\n\n\nfunction useMemoizedWatchable(w, deps) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return useWatchable(useMemo(w, deps));\n}\n/*\r\n * A hook to extract a value from a watchable. If the watchable is empty than `null` is emitted.\r\n */\n\n\nfunction useWatchable(w) {\n  return useExplicitWatchable(null, w);\n}\n/*\r\n * Similar to `useWatchable` except that it allows the loading value to be customized.\r\n */\n\n\nfunction useExplicitWatchable(loading, w) {\n  var _useState = useState(w.hasValue() ? w.getValue() : loading),\n      value = _useState[0],\n      setValue = _useState[1];\n\n  useEffect(function () {\n    return w.watch(setValue);\n  }, [w]);\n  return value;\n}\n\nexport { Watchable, WatchableSubject, partialCombineWatchable, useExplicitWatchable, useMemoizedWatchable, useWatchable };","map":{"version":3,"sources":["/Users/laurenwright/Dev/personal-site/node_modules/@shortwave/watchable/src/utils.ts","/Users/laurenwright/Dev/personal-site/node_modules/@shortwave/watchable/src/watchable.ts","/Users/laurenwright/Dev/personal-site/node_modules/@shortwave/watchable/src/hooks.ts"],"names":["Subscriptions","add","hadValue","isEmpty","forEach","Array","memoizeLatest","fn","latest","input","output","Watchable","getOrDefault","map","memoizedMapper","hasValue","getValue","watch","watcher","withHooks","setup","tearDown","count","isFirst","unsub","toPromise","resolved","resolve","snapshot","WatchableSubject","delayed","DerivedWatchable","EmptyWatchableError","Error","subscriptions","currentValue","current","value","update","elem","cb","partialCombineWatchable","subject","mapCopy","calculateLatest","watchable","updateLatest","previous","key","startWatching","unsubscribes","started","unsubscribeSubject","useMemoizedWatchable","w","deps","useWatchable","useMemo","useExplicitWatchable","loading","setValue","useState","useEffect"],"mappings":"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","sourcesContent":["export interface Box<T> {\n  current: T;\n}\n\nexport type Unsubscribe = () => void;\n\nexport class Subscriptions<CallbackType> {\n  private callbacks = new Set<CallbackType>();\n\n  add(fn: CallbackType): Unsubscribe {\n    if (this.callbacks.has(fn)) {\n      throw new Error(\"Can't add subscription twice!\");\n    }\n    this.callbacks.add(fn);\n    return () => {\n      const hadValue = this.callbacks.delete(fn);\n      if (!hadValue) {\n        throw new Error('Did not find callback function for unsubscribe');\n      }\n    };\n  }\n\n  isEmpty(): boolean {\n    return this.callbacks.size === 0;\n  }\n\n  forEach(callback: (cb: CallbackType) => void): void {\n    // Make a copy to support sync removal.\n    return Array.from(this.callbacks).forEach(callback);\n  }\n}\n\nexport function memoizeLatest<Input, Output>(\n  fn: (i: Input) => Output\n): (i: Input) => Output {\n  let latest: { input: Input; output: Output } | null = null;\n  return (input) => {\n    if (!latest) {\n      latest = { input, output: fn(input) };\n    } else if (latest.input !== input) {\n      latest.input = input;\n      latest.output = fn(input);\n    }\n    return latest.output;\n  };\n}\n\nexport interface MapLike<K, V> {\n  get(key: K): V | undefined;\n  set(key: K, value: V): void;\n  has(k: K): boolean;\n  readonly size: number;\n  [Symbol.iterator](): IterableIterator<[K, V]>;\n  keys(): IterableIterator<K>;\n  values(): IterableIterator<V>;\n}\n\nexport type MapFactory<K, V> = () => Map<K, V>;\n\nexport function defaultMapFactory<K, V>(): Map<K, V> {\n  return new Map();\n}\n","import { Subscriptions, Unsubscribe, Box, memoizeLatest } from './utils';\n\nexport type WatcherFn<T> = (value: T) => void;\n\ninterface WatchableLike<T> {\n  /** If this watchable has a current value. */\n  hasValue(): boolean;\n  /** Get the current value for this watchable, requires `hasValue` returns true. */\n  getValue(): T;\n\n  /** Watch this for updates. The current value will be replayed here. */\n  watch(watch: WatcherFn<T>): Unsubscribe;\n}\n\nexport abstract class Watchable<T> implements WatchableLike<T> {\n  abstract hasValue(): boolean;\n  abstract getValue(): T;\n  getOrDefault<V>(defaultValue: V): T | V {\n    return this.hasValue() ? this.getValue() : defaultValue;\n  }\n\n  abstract watch(watcher: WatcherFn<T>): Unsubscribe;\n\n  /* Transform this state into another value. There is basic memoization here on references. */\n  map<U>(mapper: (t: T) => U): Watchable<U> {\n    // Keep a memoized version if mapper is expensive, we also want to\n    // keep reference equality between getValue calls.\n    const memoizedMapper = memoizeLatest(mapper);\n    return new DerivedWatchable<U>({\n      hasValue: () => this.hasValue(),\n      getValue: () => memoizedMapper(this.getValue()),\n      watch: (watcher) => this.watch((v) => watcher(memoizedMapper(v))),\n    });\n  }\n\n  /*\n   * Returns a watchable that allows for callbacks when the first subscription is setup\n   * and the last watcher is torn down.\n   *\n   * Useful for tracking usage of a watchable or needing side effects when updates come in.\n   */\n  withHooks({\n    setup,\n    tearDown,\n  }: {\n    setup(): void;\n    tearDown(): void;\n  }): Watchable<T> {\n    let count = 0;\n    return new DerivedWatchable({\n      hasValue: () => this.hasValue(),\n      getValue: () => this.getValue(),\n      watch: (watch: WatcherFn<T>) => {\n        const isFirst = count === 0;\n        count++;\n        const unsub = this.watch(watch);\n        if (isFirst) {\n          setup();\n        }\n        return () => {\n          unsub();\n          count--;\n          if (count === 0) {\n            tearDown();\n          }\n        };\n      },\n    });\n  }\n\n  /* Convert the watchable into a promise that resolves when the watchable is not empty. */\n  toPromise(): Promise<T> {\n    return new Promise((resolve) => {\n      let resolved = false;\n      let unsub: Unsubscribe | null = null;\n      unsub = this.watch((v) => {\n        resolve(v);\n        // If unsub is unset then this watch fired synchronously and we just flag that\n        // this happened, otherwise we need to unsub async when the watch finally resolves.\n        if (unsub) {\n          unsub();\n        } else {\n          resolved = true;\n        }\n      });\n      if (resolved) unsub();\n    });\n  }\n\n  /** Returns either the current value as a watchable or a watchable that is empty and only updates once. */\n  snapshot(): Watchable<T> {\n    if (this.hasValue()) {\n      return WatchableSubject.of(this.getValue());\n    }\n    const delayed = WatchableSubject.empty<T>();\n    this.toPromise().then((v) => delayed.update(v));\n    return delayed;\n  }\n}\n\nclass DerivedWatchable<T> extends Watchable<T> {\n  constructor(private readonly source: WatchableLike<T>) {\n    super();\n  }\n\n  hasValue(): boolean {\n    return this.source.hasValue();\n  }\n\n  getValue(): T {\n    return this.source.getValue();\n  }\n\n  watch(watcher: WatcherFn<T>): Unsubscribe {\n    return this.source.watch(watcher);\n  }\n}\n\nclass EmptyWatchableError extends Error {\n  constructor() {\n    super('You must check hasValue() before accessing a watchable value.');\n  }\n}\n\n/** The mutable version of a watchable. */\nexport class WatchableSubject<T> extends Watchable<T> {\n  private readonly subscriptions = new Subscriptions<WatcherFn<T>>();\n\n  private currentValue: Box<T> | null = null;\n\n  private constructor(currentValue: Box<T> | null) {\n    super();\n    this.currentValue = currentValue;\n  }\n\n  hasValue(): boolean {\n    return this.currentValue !== null;\n  }\n\n  getValue(): T {\n    if (!this.currentValue) {\n      throw new EmptyWatchableError();\n    }\n    return this.currentValue.current;\n  }\n\n  static empty<T>() {\n    return new WatchableSubject<T>(null);\n  }\n\n  static of<T>(value: T) {\n    return new WatchableSubject<T>({ current: value });\n  }\n\n  /* Update the current value for this \"watchable\". Does memoization on references. */\n  update(elem: T): void {\n    if (this.currentValue && this.currentValue.current === elem) return;\n    this.currentValue = { current: elem };\n    this.subscriptions.forEach((cb) => cb(elem));\n  }\n\n  watch(watch: WatcherFn<T>): Unsubscribe {\n    const unsub = this.subscriptions.add(watch);\n    // Fire off the initial value synchronously.\n    if (this.hasValue()) watch(this.getValue());\n    return unsub;\n  }\n}\n\n/*\n * Combines a map from keys to watchables, and omits any watchables that don't have a value defined in the result.\n */\nexport function partialCombineWatchable<K, V>(\n  map: ReadonlyMap<K, Watchable<V>>\n): Watchable<Map<K, V>> {\n  if (map.size === 0) {\n    return WatchableSubject.of(new Map());\n  }\n\n  const subject = WatchableSubject.empty<Map<K, V>>();\n\n  // Make a copy in case someone mutates the map\n  const mapCopy = new Map(map);\n\n  const calculateLatest = () => {\n    const latest = new Map<K, V>();\n    mapCopy.forEach((watchable, key) => {\n      if (watchable.hasValue()) {\n        latest.set(key, watchable.getValue());\n      }\n    });\n    return latest;\n  };\n\n  const updateLatest = () => {\n    const latest = calculateLatest();\n    const previous = subject.getOrDefault(new Map<K, V>());\n    for (const [key, value] of latest.entries()) {\n      if (previous.get(key) !== value) {\n        subject.update(latest);\n        return;\n      }\n    }\n    // Note, there can never be missing keys since a watchable can never go from having a value to not having a value.\n    return;\n  };\n\n  const startWatching = (watch: WatcherFn<Map<K, V>>) => {\n    const unsubscribes: Unsubscribe[] = [];\n\n    // started is set to false during subscribing, so we don't update the map on the start of\n    // every watchable, which has O(N^2) behavior. Instead we wait until all subscriptions have started\n    // and *then* calculate the map at the end once.\n    let started = false;\n    mapCopy.forEach((watchable) => {\n      unsubscribes.push(\n        watchable.watch(() => {\n          if (!started) return;\n          updateLatest();\n        })\n      );\n    });\n    started = true;\n    const unsubscribeSubject = subject.watch(watch);\n\n    return () => {\n      unsubscribeSubject();\n      for (const unsub of unsubscribes) {\n        unsub();\n      }\n    };\n  };\n\n  updateLatest();\n\n  return new DerivedWatchable({\n    hasValue: () => subject.hasValue(),\n    getValue: () => subject.getValue(),\n    watch: (watch: WatcherFn<Map<K, V>>) => startWatching(watch),\n  });\n}\n","import { DependencyList, useEffect, useMemo, useState } from 'react';\n\nimport { Watchable } from './watchable';\n\n/*\n * A combination of useMemo and useWatchable for simple usage.\n *\n * It's suggested that this is listed as a custom hook for eslint's react-hooks plugin.\n *  Learn more: https://www.npmjs.com/package/eslint-plugin-react-hooks#user-content-advanced-configuration\n */\nexport function useMemoizedWatchable<T>(\n  w: () => Watchable<T>,\n  deps: DependencyList\n): T | null {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return useWatchable(useMemo(w, deps));\n}\n\n/*\n * A hook to extract a value from a watchable. If the watchable is empty than `null` is emitted.\n */\nexport function useWatchable<T>(w: Watchable<T>): T | null {\n  return useExplicitWatchable(null, w);\n}\n\n/*\n * Similar to `useWatchable` except that it allows the loading value to be customized.\n */\nexport function useExplicitWatchable<D, T>(loading: D, w: Watchable<T>): D | T {\n  const [value, setValue] = useState<D | T>(\n    w.hasValue() ? w.getValue() : loading\n  );\n  useEffect(() => w.watch(setValue), [w]);\n  return value;\n}\n"]},"metadata":{},"sourceType":"module"}